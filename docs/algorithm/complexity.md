我们对一个算法进行评价，一般有2个重要依据-时间复杂度和空间复杂度。

## 2.1. 时间复杂度

| 名称  |  运行时间 T(n)  |  时间举例 | 算法举例 |
| :---: | :--------: | :------: | :------: |
|  常数   | O(1) |  3  | -  |
|  线性  | O(n)  |  n | 操作数组  |
|  平方  |  O(n2) |  n2  | 冒泡排序 |
|  对数  |  O(log(n)) |   log(n)  | 二分搜索  |

1. O(1)

算法所执行的时间不会随着n的大小变化,这样的情况了称为O(1)。

```js
const a=1
```

2. O(n)

下面的for循环，会执行N次,不管N是几；都称做O(n)。

```js
 for(let i=0;i<n;i++){ 

 }
```

3. O(n2)

2次循环，内层循环会执行n*n次；也就是n2，随着n的增大，复杂度会随着n的增大，复杂度会随着平方级增加。

```js
for(let i=0; i<n; i++){
  for (let j = 0; j < n; i++) {
    
  } 
}
```
4. O(log(n)) 对数复杂度

高中数学知识， y = loga x 叫做对数函数，a是对数；y就是以a为底x的对数。

```js
for(leti=1; i<=n; i*=2){ 
  console.log(i)
}
```

我们可以看出，这个算法对元素进行跳跃式输出；就是数组从下标开始，每次都会乘以2，直到i小于n的时候结束循环。

1*2 -> 2*2 -> 4*2 -> 8*2 ....

2^1 -> 2^2 -> 2^3 -> 2^4 ....

假设i在i=i*2的规则递增了x次之后，i<=n开始不成立；那么我们可以推算出下面一个数学方程式:

```js
 2^x>=n
```

x解出来，就是大于等于以2为底n的对数

```js
x>= log2 n
```

如果把上面的 i *= 2 改为 i *= 3 ，那么这段代码的时间复杂度就是 log3 n 。

注意涉及到对数的时间复杂度，底数和系数都是要被简化掉的。那么这里的 O(n) 就可以表示为：

```js
O(log(n))
```