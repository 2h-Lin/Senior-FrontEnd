
## 1.1 认识同构

### 1.1.1 前后端分离的历史与发展

前后端不分离（JSP MVC）-> 前后端分离（AJAX）-> SPA(前端路由)-> SSR(前端后端渲染同构)

### 1.1.2 同构渲染的出现

#### 问题和背景

- SEO问题
- 首屏白屏
- Nodejs
- mvvm ssr

#### 同构 CSR+SSR

- 同构：同一套js代码运行在不同的环境
- CSR：Client-Side Rendering
- SSR：Server-Side Rendering
- Node中间层 用数据渲染动态页面

#### 优点

- 首屏快

服务端内网接口数据渲染页面，无需等待js执行完毕

- SEO

首屏页面丰富，方便爬虫

- 保留SPA优点

只有首屏是服务端渲染，之后还是走前端路由，无需刷新切换内容

#### 缺点

- 门槛高
需要理解服务端渲染，兼容服务端和客户端差异

- 难以改造

旧SPA项目难以改造成服务端同构渲染

- 占用服务器资源

动态页面的生成在服务端

#### 同构是唯一方案吗？

也可以尝试预渲染技术，适合每个用户都会返回相同的内容

## 2.2 同构的实现原理

### 2.2.1 客户端渲染

简单页面客户端渲染
```js
impot React from 'react'
import ReactDoM from 'react-dom'

ReactDoM.render(
    <h1>Hello world<h1>,
    document.getElementById('root')
)
```
SPA客户端渲染

加载HTML->js->请求数据->render

加载js到render的过程就是白屏时间

### 2.2.2 服务端渲染

HTML->js->render的过程在服务端完成

服务端不能访问dom，所以会返回创建好的字符串给浏览器；服务端渲染的优势是让用户更快的看见内容；由于服务端渲染是耗性能的，所以不能每个页面都去这么做，所以接下来我们看看同构渲染。

### 2.2.3 SSR同构渲染原理

服务端渲染 + SPA = Server-side rendering

用户首次请求会向node服务器去发送请求，node服务收到请求后再去请求数据，做首屏的渲染，渲染以后返回给浏览器，用户就会看到首屏内容；
页面加载js给dom绑定事件，并接管了路由操作和其他操作，这时候就变成了我们熟悉的SPA;这时候我们即消除了SPA的白屏时间，这时候又可以在客户端无刷新的切换页面。在这个过程中得益于虚拟dom的mvvm框架提供的服务端渲染能力；在服务端虚拟dom转换的是字符串，在客户端转换的真实的dom。

#### 优点

- SEO：首屏HTML内容丰富
- 白屏时间：没有白屏时间，页面内容直接可见
- 无刷新路由：继承SAP的优点
- 同构：一套代码，两端运行



