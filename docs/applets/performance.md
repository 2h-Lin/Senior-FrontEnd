## 1.1 小程序的工作原理
#### 常见的页面渲染方式
1. Naitve：流畅度好，但是修改和发布不够灵活
2. Web渲染：修改和发布灵活，但是加载可能不稳定，渲染有时不够流畅
3. Hybrid渲染：技术方案较多，需要选型和精心设计，找到兼顾速度和流畅性的方案

####  Hybrid渲染

Naitve和Web都有它们的优势和劣势，我们想有一种混合的方案去中和它们的优势和劣势，达到一个平衡的效果，下面有3种方案

- PhoneGap：跑的还是常见web页面，只是在页面包了一层壳，native提供一些api调用，它确实有些原生的体验
- React-Native：能达到原生体验，但稳定性没那么好
- JS-SDK：提供了一些拍照、扫一扫的原生能力

####  微信小程序的选择

基于JS-SDK和资源离线缓存的Hybrid方案
- 界面渲染采用Web技术
- 页面使用独立的Webview渲染
- 资源打包一次下载后缓存使用，并且异步更新
- 提供原生组件和原生能力调用接口

####  双线程架构

![](~@/applets/duble_layer.png)

小程序分为`逻辑层`、`渲染层`，它们之间的通信需要通过`native`;每打开一个页面会开辟一个webview，它们独立渲染；所以返回的时候，直接从内存里加载

优点：
1. 流畅性：渲染层和逻辑层分别运行在不同的线程，互不阻塞
2. 安全性：逻辑层无法直接修改渲染层的内容，也无法直接获取敏感数据
3. 灵活轻量：基础库集成在微信端，业务代码轻量话，两者都可以远程更新
4. 渲染主要还是web技术，具备了Web开发的效率和灵活

缺点：
1. 开发成本：与传统开发有所区别的语法和结构，已有的的功能无法直接运行在小程序上，需要移植成本
2. 非实时性：由于渲染层和逻辑层的分离，大多数操作都变成了异步，复杂场景处理繁琐
3. 能力限制：页面大小，打开数量和内存回收都存在限制和一定的不可控性
4. 性能优化：与传统的web开发的性能问题有所不同，需要另行优化性能问题

## 1.2 性能优化

#### 性能优化的意义
小程序也需要性能优化
- 冷启动载入慢，loading状态较长（冷启动：首次启动）
- 数据量较大的页面更新不及时，滚动卡顿
- 一些触摸反馈类的功能不流畅

### 1.2.1 加快小程序的启动速度

####  启动速度

核心：减少小程序启动时所需要下载的包体积

1. 使用分包
   - 小程序的非首页或非重要页面放入分包中，可以非常有效地减少首次下载的包体积
   - 分包还可以提升小程序整体的包体积上限，也有助于后续的首屏渲染加速
```json
{
    "pages":[
        "pages/index/index"
    ],
    "subpackages":[{
        "root":"packageA",
        "pages":[
            "pages/share/index"
        ]
    }]
}
```
2. 分包预下载
  - 正常情况下，只有在访问到了分包页面的情况下，分包才会触发下载，降低了分包页面的打开速度
   - 分包预下载可以实现访问到某个页面时，自动预下载分包的内容，做到提前下载分包，同时又不影响主包的加载速度

```json
{
    "pages":[
        "pages/index/index"
    ],
    "subpackages":[{
        "root":"packageA",
        "name":"nameA",
        "pages":[
            "pages/share/index"
        ]
    }],
    "preloadRule":{
        "pages/share/index":{
            "network":"all", // 什么网络情况下预下载，wifi/all
            "packages": ["packageA"] // 分包的root和name
        }
    }
}
```
3. 独立分包
   - 独立分包可以独立于主包运行，不需要下载主包
   - 进入普通分包或主包页面时，主包才被下载
   - 独立分包也可以配置预下载主包
   - 一个小程序可以有多个独立分包

```json
{
    "pages":[
        "pages/index/index"
    ],
    "subpackages":[{
        "root":"packageA",
        "name":"nameA",
        "pages":[
            "pages/share/index"
        ],
        "independent":true
    }],
    "preloadRule":{
        "pages/share/index":{
            "network":"all", // 什么网络情况下预下载，wifi/all
            "packages": ["__APP__"] // 可以预下载主包
        }
    }
}
```
4. 优化启动速度的其他方式

  - 删除无用代码，并开启上传压缩，降低包体积
  - 减少包内图片大小和数量，并推荐使用Webp格式图片
  - 适当使用web-view组件

### 1.2.2 加快小程序的首屏渲染

- 分块渲染：优先渲染屏幕高度的内容，其他内容待ready后再渲染
- 数据预拉取：配置首屏数据接口预拉取或则周期性更新，节省数据请求时间
- 骨架屏：使用骨架屏幕，降低用户可感知的页面渲染时间
- 避免多余数据：
  - 避免空的生命周期方法
  - 减少初始化阶段的同步形式的方法调用
  - 避免过多或过复杂的主包页面和过多的自定义组件
  - 不参与渲染的数据采用纯数据字段